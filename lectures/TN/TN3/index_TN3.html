<!DOCTYPE html>
<html lang="es" id="html-root">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Análisis de estabilidad local - EBCP Latam 2025</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="../../../images/bacteria favicon.svg">

    <link rel="stylesheet" href="../../../static/custom.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- MathJax para matemáticas -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
        window.MathJax = {
            tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Prism.js para sintaxis highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    
</head>

<body>
    <!-- Header - exactamente igual a tu index -->
    <header class="header">
        <nav class="navbar">
            <div class="nav-brand">
                <img src="../../../images/logobacteria.svg" alt="EBCP Latam Logo" class="nav-logo">
                <span class="brand-text">EBCP Latam 2025</span>
            </div>
            <div class="nav-links">
                <a href="../../../index.html" data-es="Inicio" data-en="Home">Inicio</a>
                <a href="../../../lectures.html" data-es="Lectures" data-en="Lectures">Lectures</a>
                <a href="../../../about.html" data-es="Sobre Nosotros" data-en="About Us">Sobre Nosotros</a>
                <a href="https://github.com/polarbio/wsynbio-2025" target="_blank">GitHub</a>
                
                <!-- Language Toggle -->
                <div class="language-toggle">
                    <button class="lang-btn active" data-lang="es">ESP</button>
                    <button class="lang-btn" data-lang="en">EN</button>
                </div>
            </div>
        </nav>
    </header>

    <!-- Notebook Section -->
    <section class="notebook-section">
        <div class="notebook-container">

            <!-- Header del notebook -->
            <div class="notebook-header">
                <h1 class="notebook-title"
                    data-es="Análisis de estabilidad local"
                    data-en="Local stability analysis">
                    Análisis de estabilidad local
                </h1>
                <p class="notebook-subtitle"
                   data-es="2025 Workshop en Modelamiento de Sistemas Biológicos"
                   data-en="2025 Workshop on Biological Systems Modeling">
                    2025 Workshop en Modelamiento de Sistemas Biológicos
                </p>
                <div class="notebook-meta">
                    <div data-es="Autor: Bsc. Frank Britto Bisso | Revisado por: PhD. Christian Cuba Samaniego"
                         data-en="Author: Bsc. Frank Britto Bisso | Reviewed by: PhD. Christian Cuba Samaniego">
                        Autor: Bsc. Frank Britto Bisso | Revisado por: PhD. Christian Cuba Samaniego
                    </div>
                    <div data-es="Última fecha de modificación: 12 de Julio, 2025"
                         data-en="Last modified: July 12, 2025">
                        Última fecha de modificación: 12 de Julio, 2025
                    </div>
                </div>
            </div>

            <!-- Contenido del notebook -->
            
            <!-- Celda 1: Introducción -->
            <div class="cell cell-markdown">
                
                <p data-es="Los <strong>sistemas multiestables</strong> pueden terminar en uno de los posibles estados, dependiendo de dónde comiencen, lo que se conoce como las <strong>condiciones iniciales</strong> del sistema. En circuitos biológicos, esto depende de las concentraciones iniciales de las especies químicas involucradas. Pero ¿cómo podemos saber a qué estado llegará el sistema cuando pase suficiente tiempo? Para responder a eso, necesitamos analizar la <strong>estabilidad</strong> de cada estado. Un estado se considera <strong>estable</strong> si el sistema tiende a regresar a él después de una pequeña perturbación. En cambio, un estado es <strong>inestable</strong> si incluso una perturbación leve hace que el sistema se aleje de él y se dirija hacia otro estado."
                data-en="<strong>Multistable systems</strong> can end up in one of several possible states, depending on where they start—this is known as the system’s <strong>initial conditions</strong>. In biological circuits, this depends on the initial concentrations of the chemical species involved. But how can we tell which state the system will reach after enough time has passed? To answer that, we need to analyze the <strong>stability</strong> of each state. A state is considered <strong>stable</strong> if the system tends to return to it after a small perturbation. In contrast, a state is <strong>unstable</strong> if even a slight disturbance causes the system to move away from it and toward another state.">
                    Los <strong>sistemas multiestables</strong> pueden terminar en uno de los posibles estados, dependiendo de dónde comiencen, lo que se conoce como las <strong>condiciones iniciales</strong> del sistema. En circuitos biológicos, esto depende de las concentraciones iniciales de las especies químicas involucradas. Pero ¿cómo podemos saber a qué estado llegará el sistema cuando pase suficiente tiempo? Para responder a eso, necesitamos analizar la <strong>estabilidad</strong> de cada estado. Un estado se considera <strong>estable</strong> si el sistema tiende a regresar a él después de una pequeña perturbación. En cambio, un estado es <strong>inestable</strong> si incluso una perturbación leve hace que el sistema se aleje de él y se dirija hacia otro estado.
                </p>

                <h2 data-es="¿Qué son las ecuaciones de nullclines?"
                    data-en="What are the nullclines equations?">
                    ¿Qué son las ecuaciones de nullclines?
                </h2>

                <p data-es="Una forma de identificar los estados a los que puede converger un sistema multiestable es a través de un <strong>análisis de nullclines</strong>. Las nullclines son las curvas donde la tasa de cambio de una especie química en particular es cero. Si nos enfocamos en dos especies del circuito, podemos representar sus dinámicas en un plano de fases, donde cada nullclina corresponde a una de las especies. Los puntos donde estas curvas se cruzan se llaman <strong>puntos fijos</strong>, y representan concentraciones en estado estacionario que definen los estados del sistema."
                   data-en="One way to identify the states that a multistable system can converge to is through a <strong>nullclines analysis</strong>. Nullclines are the curves where the rate of change of a particular chemical species is zero. If we focus on two species from the circuit, we can plot their dynamics in a phase plane, where each nullcline corresponds to one species. The points where these curves intersect are called <strong>fixed points</strong>, and they represent steady-state concentrations that define the states of the system.">
                   Una forma de identificar los estados a los que puede converger un sistema multiestable es a través de un <strong>análisis de nullclines</strong>. Las nullclines son las curvas donde la tasa de cambio de una especie química en particular es cero. Si nos enfocamos en dos especies del circuito, podemos representar sus dinámicas en un plano de fases, donde cada nullclina corresponde a una de las especies. Los puntos donde estas curvas se cruzan se llaman <strong>puntos fijos</strong>, y representan concentraciones en estado estacionario que definen los estados del sistema.
                </p>

                <p data-es="Para ilustrar estos conceptos, analicemos el toggle switch. De la Lecture Note #2, recordamos las ecuaciones que describen este circuito."
                data-en="To illustrate these concepts, let's analyze the toggle switch. From the Lecture Note #2, we recall the equations that describe this circuit.">
                    Para ilustrar estos conceptos, analicemos el toggle switch. De la Lecture Note #2, recordamos las ecuaciones que describen este circuito.
                </p>

                <div class="math-block">
                    $$\begin{eqnarray}
                    \frac{d}{dt}x &=& \alpha \frac{K^m}{K^m + y^m} - \delta x \\
                    \frac{d}{dt}y &=& \alpha \frac{K^m}{K^m + x^m} - \delta y
                    \end{eqnarray}$$
                </div>

                <p data-es="Para ilustrar estos conceptos, analicemos el toggle switch. De la Lecture Note #2, recordamos las ecuaciones que describen este circuito."
                data-en="To illustrate these concepts, let's analyze the toggle switch. From the Lecture Note #2, we recall the equations that describe this circuit.">
                    Para ilustrar estos conceptos, analicemos el toggle switch. De la Lecture Note #2, recordamos las ecuaciones que describen este circuito.
                </p>

                <p data-es="Aunque derivar las ecuaciones de las nullclines para este sistema es relativamente sencillo, escribamos un script que utilice <code>sympy</code> para obtener dichas ecuaciones."
                data-en="Even though deriving the nullclines equations for this system is straighforward, let's write a script that uses <code>sympy</code> to obtain the equations.">
                 Aunque derivar las ecuaciones de las nullclines para este sistema es relativamente sencillo, escribamos un script que utilice <code>sympy</code> para obtener dichas ecuaciones.   
                </p>

            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                <div class="cell-input">
                    <pre><code class="language-python">
import sympy as sym

# Definir los símbolos
x, y = sym.symbols('x y', real=True, positive=True)
alpha, K, m, delta = sym.symbols('alpha K m delta', real=True, positive=True)

# Definir las EDOs
dxdt = alpha * (K**m / (K**m + y**m)) - delta * x
dydt = alpha * (K**m / (K**m + x**m)) - delta * y

# Nullclines: igualar dx/dt = 0 y dy/dt = 0
x_nullcline = sym.Eq(dxdt, 0)
y_nullcline = sym.Eq(dydt, 0)

# Resolver para x y para y
x_nullcline_expr = sym.solve(x_nullcline, x)[0]
y_nullcline_expr = sym.solve(y_nullcline, y)[0]

# Display de nullclines como ecuaciones en formato LaTeX
x_latex = sym.latex(sym.Eq(x, x_nullcline_expr))
y_latex = sym.latex(sym.Eq(y, y_nullcline_expr))

print("Nullclina de x:", x_latex)
print("Nullclina de y:", y_latex)
                    </code></pre>
                </div>
                <div class="cell-output">
                    <pre>
  Nullclina de x: x = \frac{K^{m} \alpha}{\delta \left(K^{m} + y^{m}\right)}
  Nullclina de y: y = \frac{K^{m} \alpha}{\delta \left(K^{m} + x^{m}\right)}
                    </pre>
                </div>
            </div>

            <div class="cell cell-code lang-block" data-lang="en">
                <div class="cell-input">
                    <pre><code class="language-python">
import sympy as sym

# Define symbols
x, y = sym.symbols('x y', real=True, positive=True)
alpha, K, m, delta = sym.symbols('alpha K m delta', real=True, positive=True)

# Define the ODEs
dxdt = alpha * (K**m / (K**m + y**m)) - delta * x
dydt = alpha * (K**m / (K**m + x**m)) - delta * y

# Nullclines: set dx/dt = 0 and dy/dt = 0
x_nullcline = sym.Eq(dxdt, 0)
y_nullcline = sym.Eq(dydt, 0)

# Solve for x and y
x_nullcline_expr = sym.solve(x_nullcline, x)[0]
y_nullcline_expr = sym.solve(y_nullcline, y)[0]

# Export nullclines as LaTeX strings
x_latex = sym.latex(sym.Eq(x, x_nullcline_expr))
y_latex = sym.latex(sym.Eq(y, y_nullcline_expr))

print("x-nullcline:", x_latex)
print("y-nullcline:", y_latex)
                    </code></pre>
                </div>
                <div class="cell-output">
                    <pre>
  x-nullcline: x = \frac{K^{m} \alpha}{\delta \left(K^{m} + y^{m}\right)}
  y-nullcline: y = \frac{K^{m} \alpha}{\delta \left(K^{m} + x^{m}\right)}
                    </pre>
                </div>
            </div>

            <div class="cell cell-markdown">
                
                <p data-es="Podemos mostrar estas ecuaciones en formato LaTeX para una mejor legibilidad."
                   data-en="We can display these equations in Latex for better readibility.">
                   Podemos mostrar estas ecuaciones en formato LaTeX para una mejor legibilidad.
                </p>

                <div class="math-block">
                    $$\begin{eqnarray}
                    \bar x &=& \frac{\alpha}{\delta}\frac{K^m}{K^m + \bar y^m} \\
                    \bar y &=& \frac{\alpha}{\delta}\frac{K^m}{K^m + \bar x^m}
                    \end{eqnarray}$$
                </div>

                <p data-es="Ahora, vamos a graficar las nullclinas en el plano de fases y a encontrar los puntos fijos utilizando la función <code>intersection</code>."
                   data-en="Now, let's plot the nullclines in the phase plane, and find the fixed points using the <code>intersection</code> function.">
                   Ahora, vamos a graficar las nullclinas en el plano de fases y a encontrar los puntos fijos utilizando la función <code>intersection</code>.
                </p>

            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                    <div class="cell-input">
                        <pre><code class="language-python">
# Definimos las ecuaciones de nullclines
def null_X(Y_x,  a, d, K, m):
  X_x = (a/d) * K**m / (K**m + Y_x**m)
  return X_x


def null_Y(X_y,  a,  d, K, m):
  Y_y = (a/d) * K**m / (K**m + X_y**m)
  return Y_y
                    </code></pre>
                    </div>
                </div>

            <div class="cell cell-code lang-block" data-lang="en">
                    <div class="cell-input">
                        <pre><code class="language-python">
# Define the nullclines equations
def null_X(Y_x,  a, d, K, m):
  X_x = (a/d) * K**m / (K**m + Y_x**m)
  return X_x


def null_Y(X_y,  a,  d, K, m):
  Y_y = (a/d) * K**m / (K**m + X_y**m)
  return Y_y
                    </code></pre>
                    </div>
                </div>

                <div class="cell cell-code lang-block" data-lang="es">
                    <div class="cell-input">
                        <pre><code class="language-python">
import os, sys, subprocess
if "google.colab" in sys.modules:
  cmd = "pip install --upgrade bokeh-catplot intersect"
  process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
# ------

# Librerias para el analisis matematico
import numpy as np
from intersect import intersection

# Librerias para visualizar nuestros resultados
import bokeh.io
import bokeh.plotting
import bokeh.palettes
from bokeh.models import LinearColorMapper, ColorBar
from bokeh.models import Range1d
from bokeh.io import export_svgs

bokeh.io.output_notebook()
                    </code></pre>
                    </div>
                </div>

            <div class="cell cell-code lang-block" data-lang="en">
                    <div class="cell-input">
                        <pre><code class="language-python">
import os, sys, subprocess
if "google.colab" in sys.modules:
  cmd = "pip install --upgrade bokeh-catplot intersect"
  process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
# ------

# Libraries for mathematical analysis
import numpy as np
from intersect import intersection

# Libraries to visualize our results
import bokeh.io
import bokeh.plotting
import bokeh.palettes
from bokeh.models import LinearColorMapper, ColorBar
from bokeh.models import Range1d
from bokeh.io import export_svgs

bokeh.io.output_notebook()
                    </code></pre>
                    </div>
                </div>

                <div class="cell cell-code lang-block" data-lang="es">
                    <div class="cell-input">
                        <pre><code class="language-python">
# Definir la visualización con Bokeh
p = bokeh.plotting.figure(width = 325, height = 275,
                          x_range = Range1d(0, 3.1),
                          y_range = Range1d(0, 3.1),
                          x_axis_label = 'X',
                          y_axis_label = 'Y')

# Parámetros cinéticos
a = 2.2
K = 1
d = 1
m = 3

# Definimos las variables de estado
X_y = np.linspace(0, 3, 300)
Y_x = np.linspace(0, 3, 300)

# Calculamos las nullclines
X_x = null_X(X_y, a, d, K, m)
Y_y = null_Y(Y_x, a, d, K, m)

# Encontramos los puntos fijos mediante la función de intersección
fx_points = intersection(X_x, Y_x, X_y, Y_y)
X_i = fx_points[0]  # coordenadas en el eje x
Y_i = fx_points[1]  # coordenadas en el eje y

# Graficamos las nullclines y encontramos los puntos fijos
p.line(X_y, Y_y, line_width = 3, color = 'black')
p.line(X_x, Y_x, line_width = 3, color = 'black')
p.scatter(X_i, Y_i, size = 10, fill_color = 'black', color = 'black')

# Visualizando
bokeh.io.show(p)
                    </code></pre>
                    </div>
                </div>

            <div class="cell cell-code lang-block" data-lang="en">
                    <div class="cell-input">
                        <pre><code class="language-python">
# Define the bokeh visualization
p = bokeh.plotting.figure(width = 325, height = 275,
                          x_range = Range1d(0, 3.1),
                          y_range = Range1d(0, 3.1),
                          x_axis_label = 'X',
                          y_axis_label = 'Y')

# Kinetic parameters
a = 2.2
K = 1
d = 1
m = 3

# Definimos las variables de estados
X_y = np.linspace(0,3,300)
Y_x = np.linspace(0,3,300)

# Computing the nullclines
X_x = null_X(X_y, a, d, K, m)
Y_y = null_Y(Y_x, a, d, K, m)

# Finding the fixed points with the intersection
fx_points = intersection(X_x, Y_x, X_y, Y_y)
X_i = fx_points[0]  # x-axis coordinates
Y_i = fx_points[1]  # y-axis coordinates

# Plotting the nullclines and highlight the fixed points
p.line(X_y, Y_y, line_width = 3, color = 'black')
p.line(X_x, Y_x, line_width = 3, color = 'black')
p.scatter(X_i, Y_i, size = 10, fill_color = 'black', color = 'black')

# Visualization
bokeh.io.show(p)
                    </code></pre>
                    </div>
                </div>

                <div class="cell cell-output" style="margin-bottom: 0.5rem; text-align: center;">
            <!-- Versión en español -->
                <iframe class="lang-img" data-lang="es"
                    src="Figura 1_TN3_esp.html"
                    width="100%" height="275"
                    style="border:none; display: block;"></iframe>

                <!-- Versión en inglés -->
                <iframe class="lang-img" data-lang="en"
                    src="Figura 1_TN3_esp.html"
                    width="100%" height="275"
                    style="border:none; display: none;"></iframe>
                </div>

            <div class="cell cell-markdown">

                <h2 data-es="Linealizando utilizando series de Taylor"
                    data-en="Linearization using Taylor series">
                    Linealizando utilizando series de Taylor
                </h2>

                <p data-es="La idea detrás del análisis de estabilidad local es simplificar el comportamiento de un sistema no lineal cerca de un punto fijo mediante su <strong>linearización</strong>. Las EDOs no lineales pueden ser difíciles de analizar directamente, por lo que usamos una <strong>expansión en series de Taylor</strong> alrededor de un punto fijo para aproximar el sistema con uno lineal."
                   data-en="The idea behind local stability analysis is to simplify the behavior of a nonlinear system near a fixed point by <strong>linearizing</strong> it. Nonlinear ODEs can be difficult to analyze directly, so we use a <strong>Taylor series expansion</strong> around a fixed point to approximate the system with a linear one.">
                    La idea detrás del análisis de estabilidad local es simplificar el comportamiento de un sistema no lineal cerca de un punto fijo mediante su <strong>linearización</strong>. Las EDOs no lineales pueden ser difíciles de analizar directamente, por lo que usamos una <strong>expansión en series de Taylor</strong> alrededor de un punto fijo para aproximar el sistema con uno lineal.
                </p>

                <p data-es="Supongamos que tenemos una EDO que describe la dinámica de una especie química $Y$:"
                   data-en="Suppose we have an ODE that describes the dynamics of a chemical species $Y$:">
                    Supongamos que tenemos una EDO que describe la dinámica de una especie química $Y$:
                </p> 

                <div class="math-block">
                    $$\begin{eqnarray}
                    \frac{dy}{dt} = f(y)
                    \end{eqnarray}$$
                </div>

                <p data-es="La expansión de Taylor de $f(y)$ alrededor de un punto fijo $y_0$ será:"
                   data-en="The Taylor expansion of $f(y)$ around a fixed point $y_0$ will be:">
                    La expansión de Taylor de $f(y)$ alrededor de un punto fijo $y_0$ será:
                </p> 

                <div class="math-block">
                    $$\begin{eqnarray}
                    f(y) \approx f(y_0) + \frac{df}{dy}\bigg|_{y = y_0} (y - y_0) + \text{términos de orden superior}
                    \end{eqnarray}$$
                </div>

                <p data-es="Como $y_0$ es un punto fijo, sabemos por definición que la derivada en ese punto es cero. Por lo tanto,"
                   data-en="Since $y_0$ is a fixed point, we know by definition that the derivative at that point is zero. Hence,">
                    Como $y_0$ es un punto fijo, sabemos por definición que la derivada en ese punto es cero. Por lo tanto,
                </p>

                <div class="math-block">
                    $$\begin{eqnarray}
                    f(y_0) = 0
                    \end{eqnarray}$$
                </div>

                <p data-es="Así, la expresión se simplifica a:"
                   data-en="So the expression simplifies to:">
                    Así, la expresión se simplifica a:
                </p>

                <div class="math-block">
                    $$\begin{eqnarray}
                    f(y) \approx \frac{df}{dy}\bigg|_{y = y_0} (y - y_0)
                    \end{eqnarray}$$
                </div>

                <p data-es="Esta aproximación lineal nos permite estudiar el comportamiento local del sistema cerca de $y_0$. Para sistemas con más de una variable, la derivada $\frac{df}{dy}\bigg|_{y = y_0}$ se convierte en una <strong>matriz Jacobiana</strong>, denotada como $\nabla f(y_0)$ y evaluada en el punto fijo. Una vez más, en lugar de calcular esta matriz a mano, vamos a computarla simbólicamente usando el paquete <code>sympy</code>."
                   data-en="This linear approximation helps us study the local behavior of the system near $y_0$. For systems with more than one variable, the derivative $\frac{df}{dy}\bigg|_{y = y_0}$ becomes a <strong>Jacobian matrix</strong>, denoted as $\nabla f(y_0)$ evaluated at the fixed point. Once again, rather than calculating this matrix by hand, let's compute it symbolically using the <code>sympy</code> package.">
                    Esta aproximación lineal nos permite estudiar el comportamiento local del sistema cerca de $y_0$. Para sistemas con más de una variable, la derivada $\frac{df}{dy}\bigg|_{y = y_0}$ se convierte en una <strong>matriz Jacobiana</strong>, denotada como $\nabla f(y_0)$ y evaluada en el punto fijo. Una vez más, en lugar de calcular esta matriz a mano, vamos a computarla simbólicamente usando el paquete <code>sympy</code>.
                </p>
            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                <div class="cell-input">
                    <pre><code class="language-python">
def symbolic_jacobian(v_str, f_list):
    varss = sym.symbols(v_str)
    f = sym.sympify(f_list)
    J = sym.zeros(len(f),len(varss))
    for i, fi in enumerate(f):
        for j, s in enumerate(varss):
            J[i,j] = sym.diff(fi, s)
    return J

v_str = 'y x'
f_list = [f'(a * K**m / (K**m + y**m) - d*x)',
          f'(a * K**m / (K**m + x**m) - d*y)',
          ]

J = symbolic_jacobian(v_str, f_list)
J
                    </code></pre>
                </div>
            </div>

            <div class="cell cell-code lang-block" data-lang="en">
                <div class="cell-input">
                    <pre><code class="language-python">
def symbolic_jacobian(v_str, f_list):
    varss = sym.symbols(v_str)
    f = sym.sympify(f_list)
    J = sym.zeros(len(f),len(varss))
    for i, fi in enumerate(f):
        for j, s in enumerate(varss):
            J[i,j] = sym.diff(fi, s)
    return J

v_str = 'y x'
f_list = [f'(a * K**m / (K**m + y**m) - d*x)',
          f'(a * K**m / (K**m + x**m) - d*y)',
          ]

J = symbolic_jacobian(v_str, f_list)
J
                    </code></pre>
                </div>
            </div>

            <div class="math-block">
                $$\begin{bmatrix}
                - \dfrac{y(K_m + y_m)^2}{K_m \cdot am_y \cdot y_m} & \; - d \\
                - d & \; - \dfrac{x(K_m + x_m)^2}{K_m \cdot am_x \cdot x_m}
                \end{bmatrix}$$
            </div>

            <div class="cell cell-markdown">
                <p data-es="Ahora, vamos a reescribir nuestra matriz Jacobiana como una función para que podamos calcular su valor numéricamente."
                   data-en="Now, let's rewrite our Jacobian matrix into a function to that we can numerically compute its value.">
                   Ahora, vamos a reescribir nuestra matriz Jacobiana como una función para que podamos calcular su valor numéricamente. 
                </p>      
            </div>


            <div class="cell cell-code lang-block" data-lang="es">
                    <div class="cell-input">
                        <pre><code class="language-python">
def jacobian(y0, x0, a, d, K, m):
    # Calcular la matriz Jacobiana

    jmat = np.zeros([2,2])

    jmat[0,0] = - (K**m * a * m * y0**(m-1)) / (K**m + y0**m)**2
    jmat[0,1] = -d
    jmat[1,0] = - (K**m * a * m * x0**(m-1)) / (K**m + x0**m)**2
    jmat[1,1] = -d

    return jmat
                    </code></pre>
                    </div>
                </div>
            
            <div class="cell cell-code lang-block" data-lang="en">
                    <div class="cell-input">
                        <pre><code class="language-python">
def jacobian(y0, x0, a, d, K, m):
    # Calculate the jacobian matrix

    jmat = np.zeros([2,2])

    jmat[0,0] = - (K**m * a * m * y0**(m-1)) / (K**m + y0**m)**2
    jmat[0,1] = -d
    jmat[1,0] = - (K**m * a * m * x0**(m-1)) / (K**m + x0**m)**2
    jmat[1,1] = -d

    return jmat
                    </code></pre>
                    </div>
                </div>

            <div class="cell cell-markdown">
                
                <h2 data-es="El polinomio característico y sus eigenvalores"
                    data-en="The characteristic polynomial and its eigenvalues">
                    El polinomio característico y sus eigenvalores
                </h2>

                <p data-es="En este último paso de nuestro análisis de estabilidad local, determinaremos la estabilidad observando la <strong>parte real</strong> de los <strong>valores propios</strong> (o eigenvalores) de la matriz Jacobiana. Matemáticamente, esos valores propios son las raíces del <strong>polinomio característico</strong>. Para calcularlo, si $J$ es nuestra matriz Jacobiana, necesitamos calcular el determinante de $\lambda I - J$, donde $\lambda$ representa los valores propios, e $I$ es la matriz identidad de dimensión apropiada."
                   data-en="In this last step in our local stability analysis, we will determine the stability by looking at the <strong>real</strong> part of the <strong>eigenvalues</strong> of the Jacobian matrix. Mathematically, those eigenvalues are the roots of the <strong>characteristic polynomial</strong>. To compute it, if $J$ is our Jacobian matrix, we need to calculate the determinant of $\lambda I - J$, where $\lambda$ are the eigenvalues, and $I$ is the identity matrix of appropiate dimention.">
                    En este último paso de nuestro análisis de estabilidad local, determinaremos la estabilidad observando la <strong>parte real</strong> de los <strong>valores propios</strong> (o eigenvalores) de la matriz Jacobiana. Matemáticamente, esos valores propios son las raíces del <strong>polinomio característico</strong>. Para calcularlo, si $J$ es nuestra matriz Jacobiana, necesitamos calcular el determinante de $\lambda I - J$, donde $\lambda$ representa los valores propios, e $I$ es la matriz identidad de dimensión apropiada.
                </p>
            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                <div class="cell-input">
                    <pre><code class="language-python">
# Definir el símbolo del eigenvalores: λ
λ = sym.symbols('λ')

# Computando el polinomio caracteristico
characteristic_poly = sym.Matrix(J - λ * sym.eye(J.shape[0])).charpoly(λ)
characteristic_poly
                    </code></pre>
                </div>
            </div>

            <div class="cell cell-code lang-block" data-lang="en">
                <div class="cell-input">
                    <pre><code class="language-python">
# Define the symbolic variable for the λ
λ = sym.symbols('λ')

# Compute the characteristic polynomial using SymPy's charpoly function
characteristic_poly = sym.Matrix(J - λ * sym.eye(J.shape[0])).charpoly(λ)
characteristic_poly
                    </code></pre>
                </div>
            </div>

            <div class="math-block">
                $$\begin{eqnarray}
                \text{PurePoly}\Bigg( 
                & \frac{ 
                \lambda^2 
                + \left(
                \frac{y(K_m + y_m)^2}{K_m \cdot am_y \cdot y_m}
                + \frac{x(K_m + x_m)^2}{K_m \cdot am_x \cdot x_m}
                + 2\lambda
                \right)
                }{\lambda} 
                - d^2 \nonumber \\
                & + \left( 
                \frac{x(K_m + x_m)^2}{K_m \cdot am_x \cdot x_m} + \lambda 
                \right)
                \left( 
                 \frac{y(K_m + y_m)^2}{K_m \cdot am_y \cdot y_m} + \lambda 
                \right),
                \lambda, \text{domain} = \text{EX}
                \Bigg)
                \end{eqnarray}$$
            </div>

            <div class="cell cell-markdown">
                <p data-es="Tener una expresión explícita para el polinomio característico podría ayudarnos a entender mejor la relación entre las constantes de reacción que permiten un comportamiento deseado. Pero dejemos eso para un trabajo futuro! Terminemos nuestra nota aprendiendo cómo calcular numéricamente los valores propios."
                   data-en="Having an explicit expression for the characteristic polynomial could help us gain some insights into the relationship between the rate constants to enable a desire behavior. But let's leave that for future work! Let's finish our note by learning how to numerically calculate the eigenvalues.">
                    Tener una expresión explícita para el polinomio característico podría ayudarnos a entender mejor la relación entre las constantes de reacción que permiten un comportamiento deseado. Pero dejemos eso para un trabajo futuro! Terminemos nuestra nota aprendiendo cómo calcular numéricamente los valores propios.
                </p>
            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                <div class="cell-input">
                    <pre><code class="language-python">
# Parámetros cinéticos
a = 2.2
K = 1
d = 1
m = 3

# Definimos las variables de estado
X_y = np.linspace(0, 3, 300)
Y_x = np.linspace(0, 3, 300)

# Paso N°1: calcular los puntos fijos
X_x = null_X(X_y, a, d, K, m)
Y_y = null_Y(Y_x, a, d, K, m)
fx_points = intersection(X_x, Y_x, X_y, Y_y)
X_i = fx_points[0]  # coordenadas en el eje x
Y_i = fx_points[1]  # coordenadas en el eje y

# Calcular la Jacobiana
jmat = jacobian(Y_i[0], X_i[0], a, d, K, m)
</code></pre>
                </div>
            </div>

            <div class="cell cell-code lang-block" data-lang="en">
                <div class="cell-input">
                    <pre><code class="language-python">
# Kinetic parameters
a = 2.2
K = 1
d = 1
m = 3

# Definimos las variables de estados
X_y = np.linspace(0,3,300)
Y_x = np.linspace(0,3,300)

# Step N°1: compute the fixed points
X_x = null_X(X_y, a, d, K, m)
Y_y = null_Y(Y_x, a, d, K, m)
fx_points = intersection(X_x, Y_x, X_y, Y_y)
X_i = fx_points[0]  # x-axis coordinates
Y_i = fx_points[1]  # y-axis coordinates

# Compute the Jacobian
jmat = jacobian(Y_i[0], X_i[0], a, d, K, m)
</code></pre>
                </div>
            </div>

            <div class="cell cell-markdown">
                <p data-es="Para calcular los valores propios, usamos la función <code>linalg.eigvals</code> del paquete <code>NumPy</code>."
                   data-en="To compute the eigenvalues, we use the <code>linalg.eigvals</code> from the <code>NumPy</code> package.">
                    Para calcular los valores propios, usamos la función <code>linalg.eigvals</code> del paquete <code>NumPy</code>.
                </p>
            </div>

            <div class="cell cell-code lang-block" data-lang="es">
                <div class="cell-input">
                    <pre><code class="language-python">
# Obteniendo los eigenvalores
eign = np.linalg.eigvals(jmat)

# Mostrando los componentes reales y complejos de los eigenvalores
print("Real part:")
print(np.real(eign))
print("\nImaginary part:")
print(np.imag(eign))
                    </code></pre>
                </div>
                <div class="cell-output">
                    <pre>
   Real part:
   [-1.15652215e-05 -1.24135953e+00]

   Imaginary part:
   [0. 0.]
                    </pre>
                </div>
            </div>

            <div class="cell cell-code lang-block" data-lang="en">
                <div class="cell-input">
                    <pre><code class="language-python">
# Get the eigenvalues
eign = np.linalg.eigvals(jmat)

# Displaying the real components of eigenvalue
print("Real part:")
print(np.real(eign))
print("\nImaginary part:")
print(np.imag(eign))
                    </code></pre>
                </div>
                <div class="cell-output">
                    <pre>
   Real part:
   [-1.15652215e-05 -1.24135953e+00]

   Imaginary part:
   [0. 0.]
                    </pre>
                </div>
            </div>

            <div class="cell cell-markdown">
                <p data-es="Finalmente, necesitamos evaluar la <strong>parte real</strong> de nuestros valores propios. <br> • Si la parte real de todos los valores propios es negativa ($\mathcal{Re} (\lambda) < 0$), entonces el punto fijo donde evaluamos la Jacobiana es <strong>estable</strong>. <br> • Si la parte real de al menos un valor propio es positiva ($\mathcal{Re} (\lambda) > 0$), entonces el punto fijo donde evaluamos la Jacobiana es <strong>inestable</strong>."
                   data-en="Finally, we need to evaluate the <strong>real</strong> part of our eigenvalues. <br> • If the real part of all eigenvalues is negative ($\mathcal{Re} (\lambda) < 0)$, then the fixed point where we evaluated the Jacobian is <strong>stable</strong>. <br> • If the real part of at least one eigenvalue is positive ($\mathcal{Re} (\lambda) < 0)$, then the fixed point where we evaluated the Jacobian is <strong>unstable</strong>.">
                    Finalmente, necesitamos evaluar la <strong>parte real</strong> de nuestros valores propios. <br> • Si la parte real de todos los valores propios es negativa ($\mathcal{Re} (\lambda) < 0$), entonces el punto fijo donde evaluamos la Jacobiana es <strong>estable</strong>. <br> • Si la parte real de al menos un valor propio es positiva ($\mathcal{Re} (\lambda) > 0$), entonces el punto fijo donde evaluamos la Jacobiana es <strong>inestable</strong>.
                </p>
            </div>
            
            
            </div>
        </div>
    </section>

    <!-- Footer - exactamente igual a tu index -->
    <footer class="footer">
        <div class="container">
            <p data-es="&copy; 2025 EBCP Latam. Preparado por el Laboratorio del Dr. Christian Cuba Samaniego"
               data-en="&copy; 2025 EBCP Latam. Prepared by Dr. Christian Cuba Samaniego's Laboratory">
               &copy; 2025 EBCP Latam. Preparado por el Laboratorio del Dr. Christian Cuba Samaniego
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- JavaScript exactamente igual a tu index -->
    <script>
    class LanguageManager {
        constructor() {
            this.currentLang = localStorage.getItem('selectedLanguage') || 'es';
            this.init();
        }

        init() {
            this.setupEventListeners();
            this.setLanguage(this.currentLang);
        }

        setupEventListeners() {
            const langButtons = document.querySelectorAll('.lang-btn');
            langButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const lang = e.target.getAttribute('data-lang');
                    this.setLanguage(lang);
                });
            });
        }

        setLanguage(lang) {
            this.currentLang = lang;
            localStorage.setItem('selectedLanguage', lang);

            document.getElementById('html-root').setAttribute('lang', lang);

            // Cambiar texto según idioma
            document.querySelectorAll('[data-es][data-en]').forEach(element => {
                const text = element.getAttribute(`data-${lang}`);
                if (text) {
                    element.innerHTML = text;
                }
            });

            // Mostrar/ocultar bloques de código por idioma
            document.querySelectorAll('.lang-block').forEach(block => {
                const blockLang = block.getAttribute('data-lang');
                block.style.display = (blockLang === lang) ? 'block' : 'none';
            });

            // Mostrar/ocultar imágenes por idioma
            document.querySelectorAll('.lang-img').forEach(img => {
                const imgLang = img.getAttribute('data-lang');
                img.style.display = (imgLang === lang) ? 'block' : 'none';
            });

            // Activar botón actual
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-lang') === lang) {
                    btn.classList.add('active');
                }
            });

            // Cambiar título del documento
            const titles = {
                es: 'Análisis de estabilidad local - EBCP Latam 2025',
                en: 'Local stability analysis - EBCP Latam 2025'
            };
            document.title = titles[lang];

            // Re-renderizar MathJax si está disponible
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const lang = localStorage.getItem('selectedLanguage') || 'es';

        // Mostrar elementos iniciales (antes de inicializar LanguageManager completo)
        document.querySelectorAll('.lang-block, .lang-img').forEach(el => {
            const elLang = el.getAttribute('data-lang');
            el.style.display = (elLang === lang) ? 'block' : 'none';
        });

        // Cambiar texto inicial
        document.querySelectorAll('[data-es][data-en]').forEach(el => {
            const text = el.getAttribute(`data-${lang}`);
            if (text) {
                el.innerHTML = text;
            }
        });

        // Cambiar título inicial
        const titles = {
            es: 'Análisis de estabilidad local - EBCP Latam 2025',
            en: 'Local stability analysis - EBCP Latam 2025'
        };
        document.title = titles[lang];

        // Establecer lang del HTML
        document.getElementById('html-root').setAttribute('lang', lang);

        // Iniciar gestor de idioma completo
        new LanguageManager();
    });
</script>

<!-- Render MathJax si es necesario -->
<script>
    if (window.MathJax) {
        MathJax.typesetPromise();
    }
</script>
</body>
</html>